You are an expert full-stack developer building "Elite Drive" - a luxury car marketplace application using Docker, MongoDB, Flask, and React.

CONTEXT:
This is a complete production-ready application with:
- MongoDB database for storing luxury car inventory, customers, and test drive bookings
- Flask REST API backend with comprehensive endpoints
- Premium dark-themed React frontend with Tailwind CSS
- End-to-end testing with Playwright
- Docker containerization for all services

TECHNICAL STACK:
- Backend: Python 3.11, Flask, Flask-CORS, PyMongo
- Frontend: React 18, Vite, Tailwind CSS, Lucide-React icons
- Database: MongoDB with Mongo Express admin interface
- Testing: Python requests library for API tests, Playwright for E2E tests
- Infrastructure: Docker Compose with health checks and service dependencies

ARCHITECTURE:
1. Docker Infrastructure (docker-compose.yml):
   - db: MongoDB with persistent volume "luxury_car_data", health check enabled
   - mongo-express: Database GUI accessible on port 8081
   - api: Flask service on port 5000, depends on database health
   - ui: React service on port 3000, depends on API availability
   - test-runner: Playwright service for E2E testing
   - Network: All services on "elite-net" shared network
   - Environment: MongoDB credentials in .env file (MONGO_INITDB_ROOT_USERNAME, MONGO_INITDB_ROOT_PASSWORD)

2. Database Schema (MongoDB Collections):
   - cars: Luxury vehicles (Ferrari SF90 Stradale $625k, Porsche 911 GT3 $180k, Lamborghini Revuelto $600k, Aston Martin DBS, Tesla Model S Plaid)
   - customers: Israeli customer profiles (Yossi Levi, David Mizrahi, Moshe Biton, Sarah Ashkenazi)
   - showroom_schedules: Test drive time slots (9:00, 10:00, 11:00, 14:00, 15:00, 16:00)
   - test_drives: Booking records linking customers to cars with scheduled times
   - service_history: Maintenance records with next_service_due alerts

3. Flask API Structure (/api):
   - app.py: Main Flask application with CORS enabled
   - seed_db.py: Database population script
   - test_endpoints.py: API validation tests
   - requirements.txt: flask, flask-cors, pymongo
   - Dockerfile: python:3.11-slim base, direct package installation (no venv), runs on 0.0.0.0:5000
   - MongoDB Connection: mongodb://root:rootpassword@db:27017/

   API Endpoints:
   - GET /cars: List all luxury vehicles
   - GET /cars/brand/<brand>: Filter by brand (case-insensitive)
   - GET /schedules/car/<car_id>: Available time slots for specific car
   - POST /book-test-drive: Create booking (body: car_id, customer_id, slot_time)
   - GET /customers/<id>/history: Customer's booking history

4. React Frontend (/ui):
   - Dockerfile: node:18-alpine base, npm install, npm start
   - Build Tool: Vite with React template
   - Styling: Tailwind CSS with premium dark theme
   - API Proxy: Configured to http://localhost:5000

   Design System:
   - Colors: Deep black #0a0a0a, charcoal #1a1a1a, silver #c0c0c0, gold highlights #d4af37
   - Typography: Inter font from Google Fonts
   - Icons: lucide-react (Car, Key, Calendar, ShieldCheck, Clock)

   Components:
   - Navbar: Logo, Gallery link, Dashboard link with premium styling
   - Car Gallery: Responsive card grid with images, specs, pricing, "View Details" CTA
   - Vehicle Detail Page: Hero image, full specifications, time slot selection grid, "Request Reservation" button
   - Booking Modal: Multi-step flow (customer selection → confirmation → success message)
   - Customer Dashboard: Upcoming bookings list with booking details

5. Testing Infrastructure:
   - API Tests (test_endpoints.py): Validates all endpoints return correct status codes and data
   - E2E Tests (/tests-e2e): Playwright tests for visibility, API integration, booking flow, responsive design
   - Test Runner: Containerized Playwright service with UI dependency

IMPLEMENTATION REQUIREMENTS:
- NO Python virtual environments - install packages directly in containers
- All services must use health checks and proper dependency ordering
- Frontend must be fully responsive with mobile-first approach
- All API responses must include proper error handling
- Database connections must use internal Docker network hostnames
- Test suites must provide clear PASS/FAIL output

OPERATIONAL COMMANDS:
Build and Start:
  docker-compose up --build -d

Database Setup:
  docker compose exec api python seed_db.py

Testing:
  docker compose exec api python test_endpoints.py
  docker compose run --rm test-runner npx playwright test

Monitoring:
  docker-compose logs -f api
  docker-compose logs -f ui

QUALITY STANDARDS:
- All tests must pass before considering the application complete
- UI must match the premium dark theme specifications exactly
- API responses must be consistent and well-structured
- Error messages must be user-friendly and informative
- Code must be production-ready with no placeholder comments

Build this complete application following the architecture and requirements above. Create all necessary files, implement all features, and ensure all tests pass.